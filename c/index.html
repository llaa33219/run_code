<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>C 코드 인터랙티브 터미널</title>
  <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: black;
      color: #00ff00;
      font-family: monospace;
      box-sizing: border-box;
    }
    #terminal-container {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="terminal-container"></div>
  <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
  <script>
    // Base64 인코딩/디코딩 (모든 문자 지원)
    function base64EncodeUnicode(str) {
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
        return String.fromCharCode(parseInt(p1, 16));
      }));
    }
    function base64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
    }
    
    // 터미널 상호작용 시뮬레이션을 위한 변수들
    let accumulatedInput = ""; // 지금까지 입력된 모든 내용 (STDIN으로 제공됨)
    let lastOutput = "";         // 마지막으로 받아온 전체 출력 (누적 출력)
    let isRunning = false;       // API 실행 중이면 true
    let commandBuffer = "";      // 현재 사용자가 입력 중인 한 줄
    
    // xterm.js 터미널 생성
    const term = new Terminal();
    term.open(document.getElementById("terminal-container"));
    
    // 터미널에 텍스트를 출력하는 유틸리티 함수
    function writeToTerminal(text) {
      term.write(text);
    }
    
    /**
     * runInteractive()
     *   - 현재 URL의 ?= 뒤에 있는 base64 인코딩된 C 코드를 디코딩하여 실행합니다.
     *   - 누적된 STDIN(accumulatedInput)을 piston API에 전달하여 프로그램 전체 출력을 받아옵니다.
     *   - 이전에 받은 출력(lastOutput)과 비교해 새로운 부분(diff)만 터미널에 출력합니다.
     * 
     * 이 방식은 실제 프로세스의 상태를 유지하지 못하고 매번 전체 프로그램을 처음부터 실행하지만,
     * 사용자가 입력한 모든 내용(STDIN)을 매번 제공함으로써, scanf 등 입력을 기다리는
     * 인터랙티브 프로그램도 "누적" 입력을 통해 실행 결과를 갱신하는 효과를 냅니다.
     */
    function runInteractive() {
      isRunning = true;
      // URL의 ?= 뒤에 있는 base64 인코딩된 코드를 디코딩
      const encodedCode = window.location.search.substring(2);
      let code = "";
      try {
        code = base64DecodeUnicode(encodedCode);
      } catch (e) {
        writeToTerminal("\r\n오류: 올바르지 않은 base64 인코딩 문자열입니다.\r\n");
        isRunning = false;
        return;
      }
      
      // Piston API를 사용하여 C 코드를 컴파일 및 실행 (누적된 STDIN 사용)
      fetch("https://emkc.org/api/v2/piston/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          language: "c",
          version: "latest",
          files: [
            {
              name: "main.c",
              content: code
            }
          ],
          stdin: accumulatedInput
        })
      })
      .then(response => response.json())
      .then(data => {
        let fullOutput = "";
        if(data.compile && data.compile.output) {
          fullOutput += data.compile.output;
        }
        if(data.run && data.run.output) {
          fullOutput += data.run.output;
        }
        // fullOutput는 프로그램의 전체 출력(누적된 STDIN을 반영한 결과)
        // lastOutput가 이 fullOutput의 접두사라면, 새로 추가된 부분만 diff로 계산합니다.
        let diff = "";
        if(fullOutput.indexOf(lastOutput) === 0) {
          diff = fullOutput.substring(lastOutput.length);
        } else {
          diff = fullOutput;
        }
        lastOutput = fullOutput;
        writeToTerminal(diff);
        isRunning = false;
      })
      .catch(err => {
        writeToTerminal("\r\n오류 발생: " + err + "\r\n");
        isRunning = false;
      });
    }
    
    // 터미널 시작 시, 현재까지의 입력(accumulatedInput="")으로 실행
    runInteractive();
    
    // xterm.js 키 입력 이벤트 처리 (기본적인 터미널 입력/출력 에뮬레이션)
    term.onKey(e => {
      const ev = e.domEvent;
      const key = e.key;
      if(isRunning) return; // 실행 중에는 입력 무시
      
      if(ev.keyCode === 13) { // Enter 키
        writeToTerminal("\r\n");
        // 사용자가 입력한 현재 줄(commandBuffer)을 누적 입력에 추가 (개행 포함)
        accumulatedInput += commandBuffer + "\n";
        commandBuffer = "";
        // 새 입력을 반영하기 위해 프로그램 재실행
        runInteractive();
      } else if(ev.keyCode === 8) { // Backspace 키
        if(commandBuffer.length > 0) {
          commandBuffer = commandBuffer.slice(0, -1);
          // 터미널 상에서 커서를 한 글자 뒤로 이동하며 문자 지우기
          term.write("\b \b");
        }
      } else if(!ev.altKey && !ev.ctrlKey && !ev.metaKey) {
        // 일반 출력 가능한 문자
        commandBuffer += key;
        writeToTerminal(key);
      }
    });
  </script>
</body>
</html>
