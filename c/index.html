<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>C 코드 인터랙티브 터미널</title>
  <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: black;
      color: #00ff00;
      font-family: monospace;
      box-sizing: border-box;
    }
    #terminal-container {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="terminal-container"></div>
  <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
  <script>
    // Base64 인코딩/디코딩 함수 (모든 문자 지원)
    function base64EncodeUnicode(str) {
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
        return String.fromCharCode(parseInt(p1, 16));
      }));
    }
    function base64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
    }
    
    // 글로벌 변수들 (인터랙티브 터미널 시뮬레이션)
    let accumulatedInput = ""; // 사용자가 입력한 모든 STDIN 누적
    let isRunning = false;       // API 실행 중 여부
    let commandBuffer = "";      // 현재 입력 중인 명령줄 버퍼
    let runtimeVersion = "";     // Piston API에서 사용할 C 언어 런타임 버전
    
    // xterm.js 터미널 인스턴스 생성
    const term = new Terminal();
    term.open(document.getElementById("terminal-container"));
    
    // Piston API에서 C 언어 런타임 버전을 가져오는 함수
    function fetchCRuntimeVersion() {
      return fetch("https://emkc.org/api/v2/piston/runtimes")
        .then(response => response.json())
        .then(data => {
          const cRuntime = data.find(rt => rt.language === "c");
          if (cRuntime) {
            runtimeVersion = cRuntime.version;
          } else {
            runtimeVersion = "11.2.0";
          }
        })
        .catch(err => {
          runtimeVersion = "11.2.0";
        });
    }
    
    // 누적된 STDIN(accumulatedInput)을 포함하여 C 코드를 실행하는 함수
    function runInteractive() {
      isRunning = true;
      
      // URL의 ?= 뒤에 있는 base64 인코딩된 C 코드를 디코딩
      const encodedCode = window.location.search.substring(2);
      let code = "";
      try {
        code = base64DecodeUnicode(encodedCode);
      } catch (e) {
        term.write("\r\n오류: 올바르지 않은 base64 인코딩 문자열입니다.\r\n");
        isRunning = false;
        return;
      }
      
      // Piston API에 POST 요청: C 코드를 컴파일 및 실행 (누적된 STDIN 전달)
      fetch("https://emkc.org/api/v2/piston/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          language: "c",
          version: runtimeVersion,
          files: [{
            name: "main.c",
            content: code
          }],
          stdin: accumulatedInput
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.text().then(text => { throw new Error(text) });
        }
        return response.json();
      })
      .then(data => {
        let fullOutput = "";
        if (data.compile && data.compile.output) {
          fullOutput += data.compile.output;
        }
        if (data.run && data.run.output) {
          fullOutput += data.run.output;
        }
        // 만약 누적 입력이 있다면, 기존 프롬프트 줄("Enter a non-negative integer as the limit for Fibonacci sequence: ...")을 제거
        if (accumulatedInput.trim() !== "") {
          fullOutput = fullOutput.replace(/^Enter a non-negative integer as the limit for Fibonacci sequence:[^\n]*\r?\n?/, "");
        }
        // 불필요한 공백 및 엔터가 있다면 트리밍
        fullOutput = fullOutput.replace(/^[\r\n]+/, "");
        
        // 터미널을 깔끔하게 갱신 (이전 출력 전체를 지우고 새로 출력)
        term.clear();
        term.write(fullOutput);
        // 새 입력을 위한 프롬프트 출력
        term.write("\r\n> ");
        isRunning = false;
      })
      .catch(err => {
        term.write("\r\n오류 발생: " + err.message + "\r\n> ");
        isRunning = false;
      });
    }
    
    // 초기 단계: 먼저 C 런타임 버전을 가져온 후 초기 실행 수행
    fetchCRuntimeVersion().then(() => {
      runInteractive();
    });
    
    // xterm.js 키 입력 이벤트 처리 (터미널 입력/출력 에뮬레이션)
    term.onKey(e => {
      const ev = e.domEvent;
      const key = e.key;
      if (isRunning) return;
      
      if (ev.keyCode === 13) { // Enter 키
        term.write("\r\n");
        accumulatedInput += commandBuffer + "\n";
        commandBuffer = "";
        runInteractive();
      } else if (ev.keyCode === 8) { // Backspace 키
        if (commandBuffer.length > 0) {
          commandBuffer = commandBuffer.slice(0, -1);
          term.write("\b \b");
        }
      } else if (!ev.altKey && !ev.ctrlKey && !ev.metaKey) {
        commandBuffer += key;
        term.write(key);
      }
    });
  </script>
</body>
</html>
